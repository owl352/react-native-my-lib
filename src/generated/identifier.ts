// @ts-nocheck
// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './identifier-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArrayBuffer,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: DynamicId
export enum DynamicId_Tags {
  Str = 'Str',
  Bytes = 'Bytes',
  FfiId = 'FfiId',
}
export const DynamicId = (() => {
  type Str__interface = {
    tag: DynamicId_Tags.Str;
    inner: Readonly<{ id: string }>;
  };

  class Str_ extends UniffiEnum implements Str__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DynamicId';
    readonly tag = DynamicId_Tags.Str;
    readonly inner: Readonly<{ id: string }>;
    constructor(inner: { id: string }) {
      super('DynamicId', 'Str');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string }): Str_ {
      return new Str_(inner);
    }

    static instanceOf(obj: any): obj is Str_ {
      return obj.tag === DynamicId_Tags.Str;
    }
  }

  type Bytes__interface = {
    tag: DynamicId_Tags.Bytes;
    inner: Readonly<{ id: ArrayBuffer }>;
  };

  class Bytes_ extends UniffiEnum implements Bytes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DynamicId';
    readonly tag = DynamicId_Tags.Bytes;
    readonly inner: Readonly<{ id: ArrayBuffer }>;
    constructor(inner: { id: ArrayBuffer }) {
      super('DynamicId', 'Bytes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: ArrayBuffer }): Bytes_ {
      return new Bytes_(inner);
    }

    static instanceOf(obj: any): obj is Bytes_ {
      return obj.tag === DynamicId_Tags.Bytes;
    }
  }

  type FfiId__interface = {
    tag: DynamicId_Tags.FfiId;
    inner: Readonly<{ id: IdentifierFfiInterface }>;
  };

  class FfiId_ extends UniffiEnum implements FfiId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DynamicId';
    readonly tag = DynamicId_Tags.FfiId;
    readonly inner: Readonly<{ id: IdentifierFfiInterface }>;
    constructor(inner: { id: IdentifierFfiInterface }) {
      super('DynamicId', 'FfiId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: IdentifierFfiInterface }): FfiId_ {
      return new FfiId_(inner);
    }

    static instanceOf(obj: any): obj is FfiId_ {
      return obj.tag === DynamicId_Tags.FfiId;
    }
  }

  function instanceOf(obj: any): obj is DynamicId {
    return obj[uniffiTypeNameSymbol] === 'DynamicId';
  }

  return Object.freeze({
    instanceOf,
    Str: Str_,
    Bytes: Bytes_,
    FfiId: FfiId_,
  });
})();

export type DynamicId = InstanceType<
  (typeof DynamicId)[keyof Omit<typeof DynamicId, 'instanceOf'>]
>;

// FfiConverter for enum DynamicId
const FfiConverterTypeDynamicId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DynamicId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new DynamicId.Str({ id: FfiConverterString.read(from) });
        case 2:
          return new DynamicId.Bytes({
            id: FfiConverterArrayBuffer.read(from),
          });
        case 3:
          return new DynamicId.FfiId({
            id: FfiConverterTypeIdentifierFFI.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case DynamicId_Tags.Str: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case DynamicId_Tags.Bytes: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner.id, into);
          return;
        }
        case DynamicId_Tags.FfiId: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeIdentifierFFI.write(inner.id, into);
          return;
        }
        default:
          // Throwing from here means that DynamicId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case DynamicId_Tags.Str: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case DynamicId_Tags.Bytes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayBuffer.allocationSize(inner.id);
          return size;
        }
        case DynamicId_Tags.FfiId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeIdentifierFFI.allocationSize(inner.id);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: IdentifierErrorFfi

// Enum: IdentifierErrorFfi
export enum IdentifierErrorFfi_Tags {
  ParsingErrorBase58 = 'ParsingErrorBase58',
  ParsingErrorBytes = 'ParsingErrorBytes',
}
export const IdentifierErrorFfi = (() => {
  type ParsingErrorBase58__interface = {
    tag: IdentifierErrorFfi_Tags.ParsingErrorBase58;
    inner: Readonly<{ err: string }>;
  };

  class ParsingErrorBase58_
    extends UniffiError
    implements ParsingErrorBase58__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'IdentifierErrorFfi';
    readonly tag = IdentifierErrorFfi_Tags.ParsingErrorBase58;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('IdentifierErrorFfi', 'ParsingErrorBase58');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): ParsingErrorBase58_ {
      return new ParsingErrorBase58_(inner);
    }

    static instanceOf(obj: any): obj is ParsingErrorBase58_ {
      return obj.tag === IdentifierErrorFfi_Tags.ParsingErrorBase58;
    }

    static hasInner(obj: any): obj is ParsingErrorBase58_ {
      return ParsingErrorBase58_.instanceOf(obj);
    }

    static getInner(obj: ParsingErrorBase58_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type ParsingErrorBytes__interface = {
    tag: IdentifierErrorFfi_Tags.ParsingErrorBytes;
    inner: Readonly<{ err: string }>;
  };

  class ParsingErrorBytes_
    extends UniffiError
    implements ParsingErrorBytes__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'IdentifierErrorFfi';
    readonly tag = IdentifierErrorFfi_Tags.ParsingErrorBytes;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('IdentifierErrorFfi', 'ParsingErrorBytes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): ParsingErrorBytes_ {
      return new ParsingErrorBytes_(inner);
    }

    static instanceOf(obj: any): obj is ParsingErrorBytes_ {
      return obj.tag === IdentifierErrorFfi_Tags.ParsingErrorBytes;
    }

    static hasInner(obj: any): obj is ParsingErrorBytes_ {
      return ParsingErrorBytes_.instanceOf(obj);
    }

    static getInner(obj: ParsingErrorBytes_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is IdentifierErrorFfi {
    return obj[uniffiTypeNameSymbol] === 'IdentifierErrorFfi';
  }

  return Object.freeze({
    instanceOf,
    ParsingErrorBase58: ParsingErrorBase58_,
    ParsingErrorBytes: ParsingErrorBytes_,
  });
})();

export type IdentifierErrorFfi = InstanceType<
  (typeof IdentifierErrorFfi)[keyof Omit<
    typeof IdentifierErrorFfi,
    'instanceOf'
  >]
>;

// FfiConverter for enum IdentifierErrorFfi
const FfiConverterTypeIdentifierErrorFFI = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = IdentifierErrorFfi;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new IdentifierErrorFfi.ParsingErrorBase58({
            err: FfiConverterString.read(from),
          });
        case 2:
          return new IdentifierErrorFfi.ParsingErrorBytes({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case IdentifierErrorFfi_Tags.ParsingErrorBase58: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case IdentifierErrorFfi_Tags.ParsingErrorBytes: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that IdentifierErrorFfi_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case IdentifierErrorFfi_Tags.ParsingErrorBase58: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case IdentifierErrorFfi_Tags.ParsingErrorBytes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface IdentifierFfiInterface {
  toBase58(): string;
  toBase64(): string;
  toHex(): string;
}

export class IdentifierFfi
  extends UniffiAbstractObject
  implements IdentifierFfiInterface
{
  readonly [uniffiTypeNameSymbol] = 'IdentifierFfi';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(id: DynamicId) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeIdentifierErrorFFI.lift.bind(
        FfiConverterTypeIdentifierErrorFFI
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_identifier_fn_constructor_identifierffi_new(
          FfiConverterTypeDynamicId.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeIdentifierFfiObjectFactory.bless(pointer);
  }

  public toBase58(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_identifier_fn_method_identifierffi_to_base58(
            uniffiTypeIdentifierFfiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBase64(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_identifier_fn_method_identifierffi_to_base64(
            uniffiTypeIdentifierFfiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toHex(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_identifier_fn_method_identifierffi_to_hex(
            uniffiTypeIdentifierFfiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeIdentifierFfiObjectFactory.pointer(this);
      uniffiTypeIdentifierFfiObjectFactory.freePointer(pointer);
      uniffiTypeIdentifierFfiObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is IdentifierFfi {
    return uniffiTypeIdentifierFfiObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeIdentifierFfiObjectFactory: UniffiObjectFactory<IdentifierFfiInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): IdentifierFfiInterface {
        const instance = Object.create(IdentifierFfi.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'IdentifierFfi';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_identifierffi_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: IdentifierFfiInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: IdentifierFfiInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_identifier_fn_clone_identifierffi(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_identifier_fn_free_identifierffi(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is IdentifierFfiInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'IdentifierFfi'
        );
      },
    };
  })();
// FfiConverter for IdentifierFfiInterface
const FfiConverterTypeIdentifierFFI = new FfiConverterObject(
  uniffiTypeIdentifierFfiObjectFactory
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_identifier_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_identifier_checksum_method_identifierffi_to_base58() !==
    54885
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_identifier_checksum_method_identifierffi_to_base58'
    );
  }
  if (
    nativeModule().ubrn_uniffi_identifier_checksum_method_identifierffi_to_base64() !==
    3623
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_identifier_checksum_method_identifierffi_to_base64'
    );
  }
  if (
    nativeModule().ubrn_uniffi_identifier_checksum_method_identifierffi_to_hex() !==
    49986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_identifier_checksum_method_identifierffi_to_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_identifier_checksum_constructor_identifierffi_new() !==
    5317
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_identifier_checksum_constructor_identifierffi_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeDynamicId,
    FfiConverterTypeIdentifierErrorFFI,
    FfiConverterTypeIdentifierFFI,
  },
});
